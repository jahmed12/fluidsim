<html>
<head>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r71/three.min.js"></script>
	<script type="text/javascript" src="../node_modules/dat.gui/build/dat.gui.min.js"></script>
	<style>
		/* We want our scene to span the entire window */
		body { margin: 0; }
	</style>
	
</head>
<body>
		
	<script id="fragShader">
		uniform vec2 res;//The width and height of our screen
		uniform sampler2D bufferTexture;//Our input texture
		uniform vec3 smokeSource;//The x,y are the posiiton. The z is the power/density
		uniform float red;
		uniform float blue;
		uniform float green;
		uniform float north;
		uniform float south;
		uniform float east;
		uniform float west;
		uniform float thicc;
		void main() {
	        vec2 pixel = gl_FragCoord.xy / res.xy;
	        gl_FragColor = texture2D( bufferTexture, pixel );
			

	        //Get the distance of the current pixel from the smoke source
	        float dist = distance(smokeSource.xy,gl_FragCoord.xy);
			//Generate smoke when mouse is pressed
			
			gl_FragColor.r += red*smokeSource.z * max(15.0-dist,0.0);
			gl_FragColor.g += green*smokeSource.z * max(15.0-dist,0.0);
			gl_FragColor.b +=blue*smokeSource.z * max(15.0-dist,0.0);
  
     //Smoke diffuse
	        float xPixel = 1.0/res.x;//The size of a single pixel
	        float yPixel = 1.0/res.y;
	        vec4 rightColor = texture2D(bufferTexture,vec2(pixel.x+xPixel,pixel.y));
	        vec4 leftColor = texture2D(bufferTexture,vec2(pixel.x-xPixel,pixel.y));
	        vec4 upColor = texture2D(bufferTexture,vec2(pixel.x,pixel.y+yPixel));
	        vec4 downColor = texture2D(bufferTexture,vec2(pixel.x,pixel.y-yPixel));
//Diffuse equation
	       	float factor1 = thicc * 0.016 * (leftColor.r*east+ rightColor.r*west + downColor.r*north + upColor.r*south  - (east+north+south+west)*gl_FragColor.r);
			float factor2 = thicc * 0.016 * (leftColor.g*east + rightColor.g*west + downColor.g*north + upColor.g*south- (east+north+south+west)*gl_FragColor.g);
			float factor3 = thicc* 0.016 * (leftColor.b*east + rightColor.b*west + downColor.b*north + upColor.b*south - (east+north+south+west)*gl_FragColor.b);
		 //NOTE: all weights (north/south/east/west) must add up to the frag color coefficient (currently 6.0).
		 //if the sum of the weights is less than this value, the smoke diffuses rapidly. if they exceed this value, 
		 //it does not diffuse/expands forever.
		 //


	        //Account for low precision of texels
	        float minimum = 0.003;
			if(factor1 >= -minimum && factor1 < 0.0) factor1 = -minimum;
			if(factor2 >= -minimum && factor2 < 0.0) factor2 = -minimum;
			if(factor3 >= -minimum && factor3 < 0.0) factor3 = -minimum;

			gl_FragColor.r += factor1;
			gl_FragColor.g += factor2;
			gl_FragColor.b += factor3;
		 }
	</script>
	
	<script>
		
		var camera;
		var renderer;
		var gui; 

		function scene_setup(){
			
			

			
			//This is the basic scene setup
			scene = new THREE.Scene();
			var width = window.innerWidth;
			var height = window.innerHeight;
			//Note that we're using an orthographic camera here rather than a prespective
			camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 1, 1000 );
			camera.position.z = 2;

			renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );
		}

		var bufferScene;
		var textureA;
		var textureB;
		var bufferMaterial;
		var plane;
		var bufferObject;
		var finalMaterial;
		var quad;
		gui = new dat.GUI();
			var obj = {
				red: .5 ,
				blue: .5,
				green: .5,
				north:0.1,
				south:0.1,
				east:0.1,
				west:0.1,
				thicc:8.0
			};
			gui.green = 1.0;
			gui.red=1.0;
			gui.blue=1.0;
			gui.north = 0.1;
			gui.south = 0.1;
			gui.east = 0.1;
			gui.west = 0.1
			gui.thicc = 8.0;
			


			
			gui.add(obj, "red").min(.1).max(1.0).step(.1).onChange(function(newValue) {
				gui.red= newValue;
				buffer_texture_setup();
			});
			gui.add(obj, "blue").min(.1).max(1.0).step(.1).onChange(function(newValue) {
				gui.blue= newValue;
				buffer_texture_setup();

			});
			gui.add(obj, "green").min(.1).max(1.0).step(.1).onChange(function(newValue) {
				gui.green= newValue;
				buffer_texture_setup();
			});
			gui.add(obj, "north").min(.05).max(1.0).step(.05).onChange(function(newValue) {
				gui.north= newValue;
				buffer_texture_setup();
			});
			gui.add(obj, "south").min(.05).max(1.0).step(.05).onChange(function(newValue) {
				gui.south= newValue;
				buffer_texture_setup();
			});
			gui.add(obj, "east").min(.05).max(1.0).step(.05).onChange(function(newValue) {
				gui.east= newValue;
				buffer_texture_setup();
			});
			gui.add(obj, "west").min(.05).max(1.0).step(.05).onChange(function(newValue) {
				gui.west= newValue;
				buffer_texture_setup();
			});
			gui.add(obj, "thicc").min(1.0).max(50.0).step(1).onChange(function(newValue) {
				gui.thicc= newValue;
				buffer_texture_setup();
			});
			
			

		function buffer_texture_setup(){
			//Create buffer scene
			
			bufferScene = new THREE.Scene();
			//Create 2 buffer textures
			textureA = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, { minFilter: THREE.NearestMipmapNearestFilter, magFilter: THREE.NearestMipmapNearestFilter});
			textureB = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, { minFilter: THREE.NearestMipmapNearestFilter, magFilter: THREE.NearestMipmapNearestFilter} );
			//Pass textureA to shader
			bufferMaterial = new THREE.ShaderMaterial( {
				uniforms: {
				 bufferTexture: { type: "t", value: textureA },
				 res : {type: 'v2',value:new THREE.Vector2(window.innerWidth,window.innerHeight)},//Keeps the resolution
				 smokeSource: {type:"v3",value:new THREE.Vector3(0,0,0)},
				 time: {type:"f",value:Math.random()*Math.PI*2+Math.PI},
				 red:{type:"f", value: gui.red},
				 blue:{type:"f", value: gui.blue},
				 green:{type:"f", value: gui.green},
				 north:{type:"f", value: gui.north},
				 south:{type:"f", value: gui.south},
				 east: {type:"f", value:gui.east},
				 west: {type:"f", value:gui.west},
				 thicc: {type:"f", value:gui.thicc}

				},
				fragmentShader: document.getElementById( 'fragShader' ).innerHTML
			} );
			plane = new THREE.PlaneBufferGeometry( window.innerWidth, window.innerHeight );
			bufferObject = new THREE.Mesh( plane, bufferMaterial );
			bufferScene.add(bufferObject);

			//Draw textureB to screen 
			finalMaterial =  new THREE.MeshBasicMaterial({map: textureB});
			
			quad = new THREE.Mesh( plane, finalMaterial );
			scene.add(quad);
		}

		//Initialize the Threejs scene
		scene_setup();

		//Setup the frame buffer/texture we're going to be rendering to instead of the screen
		buffer_texture_setup();

		

		//Send position of smoke source with value
		var mouseDown = false;
		function UpdateMousePosition(X,Y){
			var mouseX = X;
		  	var mouseY = window.innerHeight - Y;
		  	bufferMaterial.uniforms.smokeSource.value.x = mouseX;
		  	bufferMaterial.uniforms.smokeSource.value.y = mouseY;
		}
		document.onmousemove = function(event){
		  	UpdateMousePosition(event.clientX,event.clientY)
		}

		document.onmousedown = function(event){
			mouseDown = true;
			bufferMaterial.uniforms.smokeSource.value.z = 0.1;
		}
		document.onmouseup = function(event){
			mouseDown = false;
			bufferMaterial.uniforms.smokeSource.value.z = 0;
		}

		//Render everything!
		function render() {

		  requestAnimationFrame( render );

		  //Draw to textureB
		  renderer.render(bufferScene,camera,textureB,true);
			
		  //Swap textureA and B
		  var t = textureA;
		  textureA = textureB;
		  textureB = t;
		  quad.material.map = textureB;
		  bufferMaterial.uniforms.bufferTexture.value = textureA;


		  //Finally, draw to the screen
		  renderer.render( scene, camera );
		}
		render();


	</script>
</body>
</html>